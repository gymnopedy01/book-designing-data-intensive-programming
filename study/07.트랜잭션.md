# 트랜잭션

## 애매모호한트랜잭션의 개념
 - 트랜잭션 : 애플리케이션에서 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶어서 한 연산으로 실행됨. 해당 연산은 전체가 성공(커밋)하거나 실패(어보트,롤백)함
### ACID의 의미
 - 원자성 Atomicity : 
 - 일관성 Consistency : 
 - 격리성 Isolation : 
 - 지속성 Duration : 

### 단일 객체 연산과 다중 객체 연산

#### 어보트
 트랜잭션의 핵심 기능이다. 오류가 생기면 어보트되고 **안전하게 재시도** 할 수 있다.


### 갱신손실방지


## 완화된 격리 수준
### 커밋 후 읽기
가장 기본적인 트랜잭션 격리는 커밋후 읽기(read committed) 이수준에서는 두가지 를 보장해준다.
- 더티 읽기 dirty read 
  - 트랜잭션이 데이터베이스에 데이터를 썻지만 아직 커밋되거나 어보트 되지 않은 상태에서 다른 트랜잭션이 이를 볼 수 있다.
  - 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다. 이는 사용자에게 혼란을 주며, 값을 읽은후 프로세스를 결정하는 트랜잭션이 있다면 잘못된 결정을 하는 원인이 될 수 있다.
  - 하나의 트랜잭션이 로우 수준 객체 잠금을 획득하여 트랜잭션이 커밋되거나 어보트될 때 까지
- 더티 쓰기 dirty write 
  - 트랜잭션이 데이터베이스에 데이터를 썻지만 아직 커밋 되거나 어보트 되지 않은 상태에서 나중에 수행한 다른 트랜잭션이 이를 덮어써서 커밋한다.
  - 동시  쓰기 작업 시 발생하는 쓰기 충돌 중 하나이다.
  - 하나의 트랜잭션이 로우 수준 객체 잠금을 획득하여 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하다가 쓰기가 끝난 후 해제하는 쓰기잠금을 통해 구현할 수 있다.
  - 대부분의 트랜잭션 구현을 통해 방지할 수 있다.
 
### 스냅숏 격리 와 반복읽기
- 읽기 스큐 read skew (혹은 비반복 읽기 nonrepeatable read)
  - 더티 읽기가 아닌 정상적인 프로세스 임에도 시간 차이로 인해 발생하는 이상 현상
  - 백업, 분석 질의, 주기적인 무결성 확인 등의 작업에서는 큰 이슈가 될 수 있음
  - **스냅숏** 격리를 통해 방지할수 있음

스큐 : 핫스팟이 있는 불균형적 작업부하, 여기서는 시간적인 이상현상

### 갱신 손실 방지
- 동시 쓰기 작업 시 발생하는 쓰기 충돌 중 하나이며, 애플리케이션이 데이터베이스에서 값을읽고 변경한 후 변경된 값을 다시 쓸때 발생(read-modify-write 주기)
- 두 트랜잭션이 read-modify-write 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경중 하나는 손실될 수 있음
- 더티 쓰기가 아닌 정상적인 프로세스임에도 결과값과 기대값이 다름
- 갱신 손실을 방지하는 방법은 아래에 따로 정리함
  - 원자적 쓰기 연산
  - 명시적인 잠금
  - 갱신손실 자동 감지   
  - compare-and-set

### 쓰기 스큐와 팬텀
- 쓰기 스큐
  - 두 트랜잭션이 두 개의 다른 객체를 갱신 하거나 같은 객체들을 읽어 그 일부를 갱신(더티 쓰기나 갱신 손실과 함께 발생할 수 있음) 할 때 정책적인 측면에서 위반 사항 발생
  - 주로 select후 요구사항의 만족 여부를 확인하여 쓰기 작업 후 커밋하는 과정에서 발생
- 팬텀(phantom) : 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과
- 충돌 구체화 : 팬텀을 구체적인 로우 집합에 대한 잠금 충돌로 변화하기 때문. 동시성을 해결하기 위해 데이터 모델을 이용하는것은 좋지 않으므로 최후의 대안


## 직렬성
### 실제적인 직렬 실행(순차적 트랜잭션)

### 2단계 잠금 (2PL)
스냅숏격리 : 읽는쪽은 결코 쓰는쪽을 막지 않으며 쓰는쪽도 결코 읽는 쪽을 막지 않는다.
공유모드(shred mode)나 독점모드(exclusive mode)
- 트랜잭션이 객체를 읽기 원한다면 공유모드로 잠금을 획득해야한다. 동시에 여러 트랜잭션이 공유모드로 잠금을 획득하는것은 허용되지만 만약 그객체에 이미 독점 모드로 잠금을 획득한 트랜잭션이 있으면 이 트랜잭션이 완료될때 까지 기다려야 한다.
- 트랜잭션이 객체에 쓰기를 원한다면 먼저 독점모드로 잠금을 획득해야한다. 다른 어떤 트랜잭션도동시에 잠ㄱ므을 획득할 수 없으므로(공유모드 든지 독점모드든지) 그객체에 잠금이 존재한다면 트랜잭션은 대기해야 한다.
- 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠ㄱ므을 독점 잠금으로 업그레이드 해야한다. 업그레이드는 ㄱ독점 잠금을 직접 획득할 때와 똑같이 동작한다.
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료(커밋 또는 어보트) 될 때 까지 잠금을 갖고 있어야 한다. 그래서 "2단계" 라는 이름이 붙었다 (트랜잭션이 실행하는 동안의) 첫번째 단계는 잠ㄱ므을 획득할때 이고 두번째 단계는 (트랜잭션의 끝에서) 모든 잠금을 해제할 때다.

### 직렬성 스냅숏 격리 같은 낙관적 동시성 제어 기법
serializable snapshot isolation

-2단계 잠금은 비관적 동시성 제어 메커니즘 (다른 트랜잭션이 획득한 잠금으로 표시되는) 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해 질때 까지 기다리는 게 낫다는 원칙 . 다중 스레드 프로그래밍에서 자교구조 보호를 위해 사용되는 상호배제(mutual exclusion)와 비슷하다.
- 직렬실행은 극단적으로 비관적
- 직렬 스냅숏 결리는 낙관적 동시 제어 기법

